1. 输入输出
- 冯诺依曼计算机和外部设备交互的手段共有两种：中断和输入输出设备，其中输入输出可以看做是中断的补充
	- 应用程序有两种形式来访问I/O端口：
		- 通过一个独立的地址空间。I/O端口的独立地址空间有2^16-1个，in和out用来在I/O端口与eax之间传递数据。还会做端口写入和读取的权限检查：
			- rflags寄存器上IOPL（I/O特权级）位进行控制
				- 如果当前的特权级别小于或等于IOPL，则下面指令允许执行：
					- in和out （正常输入输出）
					- ins和outs （string输入输出）
					- cli和sti （clear/set中断flag）
			- Task State段(TSS)的I/O权限位图
		- 通过内存映射进行I/O。相当于直接操作内存，此外，标准的分段和也保护机制也是生效的

2. 中断
- 定义：
	- 当程序正在执行时，外部事件或内部时间（除0、指令特权级别不够、访问非权威地址等）都会引起中断，中断允许原本控制流程之外的代码被执行，这段代码就是中断处理程序。一般中断处理程序是作为操作系统或驱动程序的一部分
- IDT
	- 每一个中断发生时，都会被标记为一个特殊的值，CPU会检查内存中的中断描述符表（IDT），其地址和大小存储在idtr寄存器中(64位地址+16位大小)
	- IDT的每一个条目都有16字节；第n个条目对应第n个中断，其中前30个中断是保留的，用户不能实现；每个条目包含
		- DPL(discriptor priviledge level)：描述符特权级别。当前特权级别必须要小于等于DPL
		- TYPE：类型
			- 1110类型：中断门(interrupt gate)，IF标记会在中断处理器中自动被clear
				- IF被设置时，中断才会被处理，否则忽略
			- 1111类型：陷阱门(trap gate)，IF标记不会被清除
	- 上下文切换
		- 应用代码的特权级别的ring3，而设备必须在高级特权下才能执行。因此当设备需要CPU响应并发送中断信号给CPU时，中断处理需要在高级特权下执行，因此需要修改段选择器
		- 同样，栈也需要修改：主要分为以下两种情况
			- 当IST为0时，采用标准策略。当中断发生时，ss寄存器被初始化为0，新的rsp值被加载到TSS中。然后ss的DPL被设置为合适的特权级别，最后把就的ss和rsp值保存到新的栈中
			- 当IST为1时，TSS中七个IST中的一个会被采用
	- int指令比较特殊，该指令指定中断编号，并根据指定内容去调用中断处理程序。int指令不受IF flag值的影响，但DPL还是可以用来控制中断程序的特权级别
- 中断
	- 中断处理程序处理之前，需要将一些寄存器的值进行保存，主要有：ss,rsp,rflags,cs,rip
	- 中断处理程序一般依据中断错误码去获取更多的信息。常见的中断错误码有：
		- 0， #DE，divide error
		- 2，      non-maskable external interrupt
		- 3， #BP，breakpoint
			- 调试器依赖#BP去实现单步调试。当IF被设置时，#BP中断会在每次指令执行时触发
		- 6， #UD，invalid instruction opcode
			- rip没有指向一个有效的地址
		- 8， #DF，a fault while handling interrupt
		- 13，#GP，general protection
			- 访问禁用地址，或者执行高级权限操作
		- 14，#PF，page fault
			- 访问内存页的页表条目的present被清零，此时需要重新加载该页
	- 中断处理流程一般如下：第n个中断
		- 从idtr寄存器中取出IDT地址
		- 从IDT的第128 * n的位置获取中断描述符
		- 从IDT条目中加载段选择器和中断处理程序的地址，并保存到cs和rip寄存器中，可能还会切换到高级权限，并做好寄存器保护
		- 对一些中断而言，会将错误码推到中断处理程序的栈顶，用以获取更多的信息
		- 如果描述符类型字段将其定义为中断门，IF会被清零(否则，无法保证中断处理程序去执行，因为可能被其他中断处理程序抢占)；若是陷阱门，则不会被清零，这样就允许嵌套中断处理
		- 中断处理程序处理完毕之后，调用iretq指令返回，恢复栈中保存的所有寄存其
			- 注意，call指令只会恢复rip寄存器

3. 系统调用
- 系统调用是操作系统提供给用户执行更高权限指令的函数
- 系统调用方式
	- 中断：0x80中断号是unix类w操作系统的系统调用，但是很慢，因为还需要去访问中断描述符表IDT
	- syscall和sysret：系统调用指令。与中断的差异在于：
		- 特权只会在ring0和ring3之间奇幻
		- 所有系统调用都是别同一个入口进行处理；而每一个中断号都对应了一个中断处理函数
		- 一些寄存器会被隐式调用
			- rcx用来存储之前的rip
			- r11用来存储之前的rflags
- 特殊模块寄存器
	- 系统调用过程中会使用一些特殊模块集群器，具体操作方式有两类：
		- rdmsr：接受ecx寄存器中的MSR编号，在eax中返回寄存器的值
		- wrmsr：接受ecx寄存器中的MSR编号，并将edx:eax的值写入这个特殊的寄存器
- syscall和sysret
	- syscall指令依赖于几个特殊的MSR集群器
		- STAR（编号0xC0000081）：该寄存器持有两对cs和ss寄存器的值，其中一对是为syscall准备，还有一对是为sysret准备
		- LSTAR（编号0xC0000082）：系统调用处理器的地址
		- SFMASK（编号0xC0000084）：rflags寄存器对应的那些位需要被系统调用清零
	- 系统调用的步骤：
		- 从STAR加载对应的ss值
		- 根据SFMASK修改rflags寄存器的值
		- 保存rip到rcx
		- 用LSTAR修改rip的值，并从STAR中取得新的cs和ss的值
	- 系统调用处理命令有sysret标志的结束，并从STAR中恢复cs和ss的值，并将rcx的值恢复给rip
	- 系统调用时段选择器的处理
		- 当段选择器发生变化是，需要从GDT中读取对应的值，并将其保存至对应的shadow寄存器
		- 然而在执行syscall的时候，这些shadow会家在固定的值，不会从GDT中读取
			- cs shadow寄存器
				- Base = 0
				- Limit = FFFFFH
				- Type = 112 (can be executed, was accessed)
				- S = 1 (system)
				- DPL = 0
				- P = 1
				- L = 1
				- D = 0
				- G = 1 (always the case in long mode)
			- 当CPL（当前特权级别）被设置为0时，ss shadow寄存器
				- Base = 0
				- Limit = FFFFFH
				- Type = 112
				- S = 1
				- DPL = 0
				- P = 1
				- L = 1
				- D = 1 (diffs here)
				- G = 1
		为了支持syscall，GDT需要为代码和数据存储这两个描述符
