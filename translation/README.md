1. 函数调用
- XMM寄存器
	- SSE（Streaming SIMD Extensions）扩展，加入了XMM寄存器集合，xmm0, xmm1, ..., xmm15，都是128位寄存器，主要用于：
		- 浮点数运算
		- SIMD指令，一般是一条指令操作多个数据
	- XMM寄存器的访问
		- movq用来操作xmm寄存器的低64位
		- movdqa (align，对齐)和movdqu (unalign，未对齐)可以对xmm寄存器的128位进行操作
			- 一般使用对齐指令，否则对性能有一点影响，SSE指令一般都是对齐操作
- 调用规约
	- 程序员需要遵守的关于函数调用的约定，具体如下：
		- 需要的对值进行保护的寄存器需要将原来的值保存起来，如rsp, rbp, rip, r12-15，这些寄存器的值如果重要，就需要保存起来
		- 寄存器和栈都会被参数填充，每个参数都会被round到8个字节
			- 指针和整形参数
				- 前六个参数通过通用寄存器传入: rdi, rsi, rdx, rcx, r8, r9
			- float和double类型
				- 前八个参数通过xmm0, ..., xmm7传入
			- 结构体参数
				- 如果结构体大于32字节，或者包含未对齐的字段，就会通过内存传入
				- 小结构体则会按照其字段被分解为多个字段分别处理，如果包含嵌套结构，则递归处理
					- 也即包含两个字段的结构体可以被当做两个参数处理
			- 如果前两种类型的参数超过了指令数量，则栈会被用来存储多余的参数，按照从右到左的顺序入栈
				- 举例：当整形参数超过6个，从最后一个参数开会到第7个参数顺序入栈
		- 返回值
			- 整形和指针用rax和rdx来返回
			- 浮点数用xmm0和xmm1来返回
			- 结构体会以一个指针形式返回，该指针以隐藏的附加参数返回
		- 函数调用指令call
			- call指令的参数是调用函数的第一条指令地址，同时还会函数调用完毕后的下一条指令push到栈上，作为函数的返回指令
	- 函数调用的栈帧
		- 函数专用的栈，保存了局部变量，临时变量及保存的寄存器的值
		- 函数代码一般被prologue和epilogue包围，其中prologue是用来初始化栈帧，而epilogue则是用来销毁
			- prologue举例
				- func:
				- push rbp		; 保存caller的栈底
				- mov rbp, rsp	; 设置当前函数的栈底，此时rsp中存储的就是rbp的老值
				- sub rsp, 0x10	; 为当前函数分配新的栈帧空间
			- epilogue举例
				- mov rsp, rbp	; 释放当前函数的栈帧空间
				- pop rbp		; 恢复caller的栈底
				- ret			; 函数调用返回，并执行下一条指令
			- 其中epilogue的前两条指令等价于`leave`指令	
- red zone
	- rsp向低地址延伸的128字节区域
		- 在不改变rsp的前提下，在red zone上存放数据是安全的，不会被系统调用覆盖
			- 当rsp发生变化时，这就不安全了
		- 其实就相当于rbp，并通过相对地址进行访问
	- 这其实是一种优化策略，当一个函数在其生命周期内不会调用其他函数，就可以忽略栈帧的创建，局部变量和参数都可以借助rsp的相对地址访问，前提是：
		- 局部变量的大小不超过128字节
		- 函数是叶子函数
		- 函数不修改rsp的值

2. volatile关键字
- 对编译器的优化关节有至关重要的影响
	- 编译器在编译时会对代码进行一定程度的指令重排和乱序执行，并且如果程序读取一个从来没有被写入过的变量，那么会直接删除这条指令
	- 但是，如果变量类型是volatile，无论读写，都不会被优化，其操作顺序也是按照代码中指定的顺序
- 使用场景
	- 内存映射I/O，使用专用内存区域与外部设备进行通讯
	- 线程之间共享内存
		- 实际上只依赖volatile还是满足不了，并发场景下还需要一些其他机制
- 内存懒分配
	- 很多操作系统对页的分配都采用‘懒映射原则’，实际的映射实在调用mmap之后首次使用内存区域才会执行
	- 为了避免这种懒映射原则，可以如下：
		- 对页进行一次寻址
			- 有被操作系统优化的风险
		- 使用volatile关键字防止其被编译器优化
