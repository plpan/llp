1. 缓存
- 什么是缓存？
	- 互联网就好比一个巨大的存储资源池，当用户想要访问某一资源时，可以通过网络请求获取；但是如果每次都通过网络请求来获取资源，首先是慢，其次是资源消耗高；如果我们将已经获取的资源存储在本地，当再次访问时直接从本地读取，能够极大地提升资源获取的效率。这就是缓存，缓存适用于互联网中的所有场景。
- 缓存的类型
	- 网络请求的缓存
	- 内存相对于磁盘就是缓存；内存访问速度远高于磁盘
	- CPU cache相对于内存就是缓存，L1, L2, L3, 内存的速度逐级递减
		- 为此，CPU至少拥有一个指令缓存（存储指令的队列）和一个TLB(Translation Lookaside Buffer)来提升虚拟内存的性能
	- 寄存器相对于CPU cache就是缓存
- 为什么有缓存？
	- 局部性：因为每时每刻我们访问的数据只有一小部分
		- 绝大多数的程序消耗时间实在循环里
		- 绝大多数的数据访问是重复连续的

2. 虚拟内存
- 什么是虚拟内存？
	- 虚拟内存是计算机系统内存管理的一种技术。它使应用程序认为自己拥有一个连续完整的地址空间，而实际上，它的地址空间通常被分为多个物理内存碎片，甚至部分内容暂时还存储在物理磁盘上，当这部分数据需要被使用时，通过内存页置换将这一部分内容加载进内存。
- 为什么需要虚拟内存？
	- 应用程序可能很大，超过物理内存的大小限制，因此操作系统需要提供部分加载的能力
	- 内存中存在多个程序，不同应用程序之间处理速度不一致，甚至还需要和慢速设备，如磁盘，打交道，因此需要提供程序间切换的能力；但是程序切换要求程序的数据必须在内存中，否则会花费大量的时间用于加载应用程序的数据
	- 程序可以被存储到内存的任意位置，这样就可以用任意空闲内存块来加载程序了；即使程序内部使用绝对地址
	- 有效使用共享数据和代码，拷贝复制的成本太高
	- 最关键的是解放程序员，程序员应该关注的是程序逻辑，而不是内存如何分配的
- 地址空间
	- 地址空间就是一段范围的地址。一般来说有两种：
		- 物理地址：访问真实硬件中的字节数据
			- 物理地址是有上限的，处理器无法超出这个容量
			- 处理器的可操作地址是有寻址能力决定的。32位操作系统最大内存不能超过4GB。当然，少于4GB的物理内存也是可以的，但是部分物理地址空间就是无效地址，应禁止访问
		- 逻辑地址：应用程序的地址空间，应用程序不会访问到其他程序的数据和指令
	- 操作系统使用MMU (Memory Management Unit) 完成逻辑地址与物理地址之间的转换
- 特性
	- 虚拟内存在内存空间上实现了隔离，使得每一个应用程序都任务自己是唯一的内存用户
	- 单个进程的地址空间被划分为相等长度的页（一般4KB）；这些页被动态的管理起来，有些页可能会被置换到外部设备，而在需要的时候再置换回来
	- 虚拟内存通过对内存页的内存操作可以实现：
		- 通过内存输入/输出的映射方式实现与外置存储的通信（写入数据到外部设备地址，或从该地址读取数据）
		- 在操作系统和文件系统的帮助下，实现内存页与外部储存文件的通信
		- 某些内存页可以被多个进程共享
		- 因为大部分内存地址是禁用的（未定义），当尝试访问这些地址时，会导致程序异常终止。Segmentation Fault！
		- 一些内存页与外存里文件关联（可执行文件、库等），但还有一些没有关联外部文件；这些被称为匿名页，匿名页和堆、栈的内存区域相关联。之所以被称为匿名页，是因为这些页没有在文件系统中关联的内容
	- 替换策略：如果空闲物理内存使用完，一些页就会被替换到外部存储（swap文件）中，或者被丢弃。
		- swap文件
			- Windows系统中，这些文件叫PageFile.sys
			- *nix系统会在磁盘中专门设置一个swap分区
		- 替换策略
			- 最近最少使用
			- 随机
			- ...
		- 有cache的任何类型系统都有替换策略
	- 每一个进程都有一个内存页工作组，记录当前在内存的页。当需要更多内存页时，会向操作系统请求更多页。操作系统会为其分配更多可用内存地址;高级语言的动态内存分配最终都会变成向系统请求内存页

3. 内存地址布局
- linux系统下提供了一系列简单的手段帮助用户探索系统：关于进程，提供了一个procfs，挂载在/proc路径下。它是一种特殊的文件系统，通过对路径和文件的访问，可以获取任意进程的内存、环境变量等信息。
	- /proc/PID/maps 存储了进程PID的内存信息，共包含六项；每一项都与一个vm_area_struct结构一一对应
		- 地址：库在进程中的地址范围
			- 从结果中可以看出，每一条记录的其实地址都是0x1000的倍数，这是因为页的大小为4KB，而内存又是以页的形式组织
		- 权限：虚拟内存的权限；r读，w写，x执行，s共享，p私有
		- 偏移量：库在进程中的地址偏移
		- 设备：映像文件的主设备号和次设备号
		- 节点：映像文件的节点号
		- 路径：映像文件的路径
	- /proc/PID/maps 文件记录前两行记录
		- 00400000-00401000 r-xp 00000000 08:01 144225 /home/stud/main
			- 应用程序正文段(r-xp)，包含编码后的指令
		- 00600000-00601000 rwxp 00000000 08:01 144225 /home/stud/main
			- 应用程序的数据段(rwxp)
- 从/proc/PID/maps 结果可以看出，内存地址空间是无限大(2^64-1)，但是应用程序可用的地址空间其实是有限的，当访问可用地址之外的地址时，会Segmentation Fault

4. 地址翻译
- 64位虚拟地址构成
	- 16位符号位 + 9位Level 4 Pagemap Table索引 + 9位Page Directory Pointer Table索引 + 9位Page Directory索引 + 9位Page Table索引 + 12位页偏移
	- 左边17位必须是相等的，否则会报 bus error 错误
	- 虚拟地址的四个索引部分代表了地址索引表中的索引位置。翻译表中的每条记录都是64位，包含了下一个表的起始地址和一些flag数据
- 页帧
	- 物理地址空间被划分为多个槽，被称为页帧，页帧的大小为4KB，页帧之间不存在空隙；因此，页帧的偏移始终未4KB的倍数，也即页帧的低12位始终为0
	- 虚拟地址和物理地址的最低12位对应了页帧中的偏移值，因此两个地址的低12位是相等的
- 地址翻译
	- 首先，从cr3中获取PML4表的起始地址，获取元素流程：
		- 51-12位由cr3提供
		- 11-3位由虚拟地址的48-39位提供（也即Level 4 Pagemap Table索引）
		- 最后3位填0
	- 然后，依次按照同样的方式对余下的索引进行查找，最后找到需要的页帧的地址（51-12位），并将物理地址的低12位与之相加，就得到了完整的虚拟地址了
- TLB表
	- 如果每次对内存的访问都要经历这么多次内存读取（查表），那么不用想也很慢。幸亏有TLB表提供了页地址缓存。感谢程序的局部性，我们访问的大多数页都是已经被翻译过的地址和已经加载记忆的页，再次基础上，我们加上页内偏移就可以直接对物理内存进行访问
	- TLB表是联合缓存，在给定页虚拟地址的前提下，它能够非常快地给出翻译后的页地址
	- TLB表条目结构
		- 63位：EXB(Execution Disabled Bit)：禁止执行位，在该页上禁止指令执行
		- 47-12位：page frame
		- 11-9位：AVL：面向操作系统开发者
		- 6位：D：脏页
		- 5位：A：被访问过
		- 4位：PCD(Page Cache Disable)：禁用页缓存
		- 3位：PWT(Page Write-Through)：通路写入，当写入到页时，直接越过cache
		- 2位：U：用户级（ring3用户态下可访问）
		- 1位：W：可写
		- 0位：P：是否在物理内存中
	- 注意：
		- 当P没有设置，访问该页时，会触发一个PageFault中断，操作系统会处理这个中断，并加载该页
			- 可以懒加载，当真正使用该页时，才触发加载
		- W用来保护页不被修改，共享代码和数据时需要使用这一位
		- EXB是禁止代码执行，可以用来抵御部分攻击手段，同样的.text则有W来进行保护，防止其被篡改
- 页大小
	- 一般内存页的大小为4KB。当然这个值是可以改变的，可以更改为更大的值。

5. 内存映射
- 概念
	- 建立实体（文件、设备、物理内存）和虚拟内存之间的映射关系。当loader填充进程地址空间后，进程向操作系统请求某个也，操作系统将文件内容映射至进程的地址空间。常见的内存映射有mmap和munmap，他们都依赖于另一个系统调用open
	- open系统调用
		- rax：2，系统调用号
		- rdi：文件名，字符串指针
		- rsi：flags，权限标记位组合（读、写、...）
		- rdx：mode，当创建文件时，需要指定文件的权限
		- open系统调用完成后，rax持有返回的文件描述符
	- mmap系统调用
		- rax：9，系统调用号
		- rdi：addr，操作系统从这个指定的位置（页的起始地址）开始映射内存页；若为0表示从任意位置开始映射内存页
		- rsi：len，内存region大小
		- rdx：prot，保护flag (write, read, execute, ..)
		- r10：flags，共有flag （共享、私有、匿名页）
		- r8：fd，可选的映射文件，该文件已经执行过open
		- r9：offset，文件的偏移
		- mmap系统调用完成后，rax持有一个指向新分配的内存页的指针
	- mmap prot选项
		- PROT_EXEC：page可执行
		- PROT_READ：page可读
		- PROT_WRITE：page可写
		- PROT_NONE：page不可被访问
